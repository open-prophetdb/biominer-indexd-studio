(self.webpackChunkbiominer_indexd_studio=self.webpackChunkbiominer_indexd_studio||[]).push([[5909],{32676:function(dt,Xt,Et){var et=Et(34155);(function(nt,N){dt.exports=N()})(this,function(){"use strict";function nt(s,t){var e={label:0,sent:function(){if(i[0]&1)throw i[1];return i[1]},trys:[],ops:[]},n,r,i,u;return u={next:l(0),throw:l(1),return:l(2)},typeof Symbol=="function"&&(u[Symbol.iterator]=function(){return this}),u;function l(h){return function(p){return f([h,p])}}function f(h){if(n)throw new TypeError("Generator is already executing.");for(;e;)try{if(n=1,r&&(i=h[0]&2?r.return:h[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,h[1])).done)return i;switch(r=0,i&&(h=[h[0]&2,i.value]),h[0]){case 0:case 1:i=h;break;case 4:return e.label++,{value:h[1],done:!1};case 5:e.label++,r=h[1],h=[0];continue;case 7:h=e.ops.pop(),e.trys.pop();continue;default:if(i=e.trys,!(i=i.length>0&&i[i.length-1])&&(h[0]===6||h[0]===2)){e=0;continue}if(h[0]===3&&(!i||h[1]>i[0]&&h[1]<i[3])){e.label=h[1];break}if(h[0]===6&&e.label<i[1]){e.label=i[1],i=h;break}if(i&&e.label<i[2]){e.label=i[2],e.ops.push(h);break}i[2]&&e.ops.pop(),e.trys.pop();continue}h=t.call(s,e)}catch(p){h=[6,p],r=0}finally{n=i=0}if(h[0]&5)throw h[1];return{value:h[0]?h[1]:void 0,done:!0}}}var N=function(){function s(t,e){this.next=null,this.key=t,this.data=e,this.left=null,this.right=null}return s}();function vt(s,t){return s>t?1:s<t?-1:0}function z(s,t,e){for(var n=new N(null,null),r=n,i=n;;){var u=e(s,t.key);if(u<0){if(t.left===null)break;if(e(s,t.left.key)<0){var l=t.left;if(t.left=l.right,l.right=t,t=l,t.left===null)break}i.left=t,i=t,t=t.left}else if(u>0){if(t.right===null)break;if(e(s,t.right.key)>0){var l=t.right;if(t.right=l.left,l.left=t,t=l,t.right===null)break}r.right=t,r=t,t=t.right}else break}return r.right=t.left,i.left=t.right,t.left=n.right,t.right=n.left,t}function D(s,t,e,n){var r=new N(s,t);if(e===null)return r.left=r.right=null,r;e=z(s,e,n);var i=n(s,e.key);return i<0?(r.left=e.left,r.right=e,e.left=null):i>=0&&(r.right=e.right,r.left=e,e.right=null),r}function it(s,t,e){var n=null,r=null;if(t){t=z(s,t,e);var i=e(t.key,s);i===0?(n=t.left,r=t.right):i<0?(r=t.right,t.right=null,n=t):(n=t.left,t.left=null,r=t)}return{left:n,right:r}}function mt(s,t,e){return t===null?s:(s===null||(t=z(s.key,t,e),t.left=s),t)}function V(s,t,e,n,r){if(s){n(""+t+(e?"\u2514\u2500\u2500 ":"\u251C\u2500\u2500 ")+r(s)+`
`);var i=t+(e?"    ":"\u2502   ");s.left&&V(s.left,i,!1,n,r),s.right&&V(s.right,i,!0,n,r)}}var H=function(){function s(t){t===void 0&&(t=vt),this._root=null,this._size=0,this._comparator=t}return s.prototype.insert=function(t,e){return this._size++,this._root=D(t,e,this._root,this._comparator)},s.prototype.add=function(t,e){var n=new N(t,e);this._root===null&&(n.left=n.right=null,this._size++,this._root=n);var r=this._comparator,i=z(t,this._root,r),u=r(t,i.key);return u===0?this._root=i:(u<0?(n.left=i.left,n.right=i,i.left=null):u>0&&(n.right=i.right,n.left=i,i.right=null),this._size++,this._root=n),this._root},s.prototype.remove=function(t){this._root=this._remove(t,this._root,this._comparator)},s.prototype._remove=function(t,e,n){var r;if(e===null)return null;e=z(t,e,n);var i=n(t,e.key);return i===0?(e.left===null?r=e.right:(r=z(t,e.left,n),r.right=e.right),this._size--,r):e},s.prototype.pop=function(){var t=this._root;if(t){for(;t.left;)t=t.left;return this._root=z(t.key,this._root,this._comparator),this._root=this._remove(t.key,this._root,this._comparator),{key:t.key,data:t.data}}return null},s.prototype.findStatic=function(t){for(var e=this._root,n=this._comparator;e;){var r=n(t,e.key);if(r===0)return e;r<0?e=e.left:e=e.right}return null},s.prototype.find=function(t){return this._root&&(this._root=z(t,this._root,this._comparator),this._comparator(t,this._root.key)!==0)?null:this._root},s.prototype.contains=function(t){for(var e=this._root,n=this._comparator;e;){var r=n(t,e.key);if(r===0)return!0;r<0?e=e.left:e=e.right}return!1},s.prototype.forEach=function(t,e){for(var n=this._root,r=[],i=!1;!i;)n!==null?(r.push(n),n=n.left):r.length!==0?(n=r.pop(),t.call(e,n),n=n.right):i=!0;return this},s.prototype.range=function(t,e,n,r){for(var i=[],u=this._comparator,l=this._root,f;i.length!==0||l;)if(l)i.push(l),l=l.left;else{if(l=i.pop(),f=u(l.key,e),f>0)break;if(u(l.key,t)>=0&&n.call(r,l))return this;l=l.right}return this},s.prototype.keys=function(){var t=[];return this.forEach(function(e){var n=e.key;return t.push(n)}),t},s.prototype.values=function(){var t=[];return this.forEach(function(e){var n=e.data;return t.push(n)}),t},s.prototype.min=function(){return this._root?this.minNode(this._root).key:null},s.prototype.max=function(){return this._root?this.maxNode(this._root).key:null},s.prototype.minNode=function(t){if(t===void 0&&(t=this._root),t)for(;t.left;)t=t.left;return t},s.prototype.maxNode=function(t){if(t===void 0&&(t=this._root),t)for(;t.right;)t=t.right;return t},s.prototype.at=function(t){for(var e=this._root,n=!1,r=0,i=[];!n;)if(e)i.push(e),e=e.left;else if(i.length>0){if(e=i.pop(),r===t)return e;r++,e=e.right}else n=!0;return null},s.prototype.next=function(t){var e=this._root,n=null;if(t.right){for(n=t.right;n.left;)n=n.left;return n}for(var r=this._comparator;e;){var i=r(t.key,e.key);if(i===0)break;i<0?(n=e,e=e.left):e=e.right}return n},s.prototype.prev=function(t){var e=this._root,n=null;if(t.left!==null){for(n=t.left;n.right;)n=n.right;return n}for(var r=this._comparator;e;){var i=r(t.key,e.key);if(i===0)break;i<0?e=e.left:(n=e,e=e.right)}return n},s.prototype.clear=function(){return this._root=null,this._size=0,this},s.prototype.toList=function(){return bt(this._root)},s.prototype.load=function(t,e,n){e===void 0&&(e=[]),n===void 0&&(n=!1);var r=t.length,i=this._comparator;if(n&&J(t,e,0,r-1,i),this._root===null)this._root=W(t,e,0,r),this._size=r;else{var u=St(this.toList(),wt(t,e),i);r=this._size+r,this._root=Z({head:u},0,r)}return this},s.prototype.isEmpty=function(){return this._root===null},Object.defineProperty(s.prototype,"size",{get:function(){return this._size},enumerable:!0,configurable:!0}),Object.defineProperty(s.prototype,"root",{get:function(){return this._root},enumerable:!0,configurable:!0}),s.prototype.toString=function(t){t===void 0&&(t=function(n){return String(n.key)});var e=[];return V(this._root,"",!0,function(n){return e.push(n)},t),e.join("")},s.prototype.update=function(t,e,n){var r=this._comparator,i=it(t,this._root,r),u=i.left,l=i.right;r(t,e)<0?l=D(e,n,l,r):u=D(e,n,u,r),this._root=mt(u,l,r)},s.prototype.split=function(t){return it(t,this._root,this._comparator)},s.prototype[Symbol.iterator]=function(){var t,e,n;return nt(this,function(r){switch(r.label){case 0:t=this._root,e=[],n=!1,r.label=1;case 1:return n?[3,6]:t===null?[3,2]:(e.push(t),t=t.left,[3,5]);case 2:return e.length===0?[3,4]:(t=e.pop(),[4,t]);case 3:return r.sent(),t=t.right,[3,5];case 4:n=!0,r.label=5;case 5:return[3,1];case 6:return[2]}})},s}();function W(s,t,e,n){var r=n-e;if(r>0){var i=e+Math.floor(r/2),u=s[i],l=t[i],f=new N(u,l);return f.left=W(s,t,e,i),f.right=W(s,t,i+1,n),f}return null}function wt(s,t){for(var e=new N(null,null),n=e,r=0;r<s.length;r++)n=n.next=new N(s[r],t[r]);return n.next=null,e.next}function bt(s){for(var t=s,e=[],n=!1,r=new N(null,null),i=r;!n;)t?(e.push(t),t=t.left):e.length>0?(t=i=i.next=e.pop(),t=t.right):n=!0;return i.next=null,r.next}function Z(s,t,e){var n=e-t;if(n>0){var r=t+Math.floor(n/2),i=Z(s,t,r),u=s.head;return u.left=i,s.head=s.head.next,u.right=Z(s,r+1,e),u}return null}function St(s,t,e){for(var n=new N(null,null),r=n,i=s,u=t;i!==null&&u!==null;)e(i.key,u.key)<0?(r.next=i,i=i.next):(r.next=u,u=u.next),r=r.next;return i!==null?r.next=i:u!==null&&(r.next=u),n.next}function J(s,t,e,n,r){if(!(e>=n)){for(var i=s[e+n>>1],u=e-1,l=n+1;;){do u++;while(r(s[u],i)<0);do l--;while(r(s[l],i)>0);if(u>=l)break;var f=s[u];s[u]=s[l],s[l]=f,f=t[u],t[u]=t[l],t[l]=f}J(s,t,e,l,r),J(s,t,l+1,n,r)}}const F=(s,t)=>s.ll.x<=t.x&&t.x<=s.ur.x&&s.ll.y<=t.y&&t.y<=s.ur.y,K=(s,t)=>{if(t.ur.x<s.ll.x||s.ur.x<t.ll.x||t.ur.y<s.ll.y||s.ur.y<t.ll.y)return null;const e=s.ll.x<t.ll.x?t.ll.x:s.ll.x,n=s.ur.x<t.ur.x?s.ur.x:t.ur.x,r=s.ll.y<t.ll.y?t.ll.y:s.ll.y,i=s.ur.y<t.ur.y?s.ur.y:t.ur.y;return{ll:{x:e,y:r},ur:{x:n,y:i}}};let $=Number.EPSILON;$===void 0&&($=Math.pow(2,-52));const _t=$*$,rt=(s,t)=>{if(-$<s&&s<$&&-$<t&&t<$)return 0;const e=s-t;return e*e<_t*s*t?0:s<t?-1:1};class It{constructor(){this.reset()}reset(){this.xRounder=new st,this.yRounder=new st}round(t,e){return{x:this.xRounder.round(t),y:this.yRounder.round(e)}}}class st{constructor(){this.tree=new H,this.round(0)}round(t){const e=this.tree.add(t),n=this.tree.prev(e);if(n!==null&&rt(e.key,n.key)===0)return this.tree.remove(t),n.key;const r=this.tree.next(e);return r!==null&&rt(e.key,r.key)===0?(this.tree.remove(t),r.key):t}}const G=new It,B=11102230246251565e-32,m=134217729,Pt=(3+8*B)*B;function tt(s,t,e,n,r){let i,u,l,f,h=t[0],p=n[0],o=0,c=0;p>h==p>-h?(i=h,h=t[++o]):(i=p,p=n[++c]);let a=0;if(o<s&&c<e)for(p>h==p>-h?(u=h+i,l=i-(u-h),h=t[++o]):(u=p+i,l=i-(u-p),p=n[++c]),i=u,l!==0&&(r[a++]=l);o<s&&c<e;)p>h==p>-h?(u=i+h,f=u-i,l=i-(u-f)+(h-f),h=t[++o]):(u=i+p,f=u-i,l=i-(u-f)+(p-f),p=n[++c]),i=u,l!==0&&(r[a++]=l);for(;o<s;)u=i+h,f=u-i,l=i-(u-f)+(h-f),h=t[++o],i=u,l!==0&&(r[a++]=l);for(;c<e;)u=i+p,f=u-i,l=i-(u-f)+(p-f),p=n[++c],i=u,l!==0&&(r[a++]=l);return(i!==0||a===0)&&(r[a++]=i),a}function Rt(s,t){let e=t[0];for(let n=1;n<s;n++)e+=t[n];return e}function U(s){return new Float64Array(s)}const Mt=(3+16*B)*B,At=(2+12*B)*B,Lt=(9+64*B)*B*B,j=U(4),ot=U(8),lt=U(12),ut=U(16),I=U(4);function kt(s,t,e,n,r,i,u){let l,f,h,p,o,c,a,x,g,d,y,E,w,v,b,S,R,_;const A=s-r,L=e-r,k=t-i,O=n-i;v=A*O,c=m*A,a=c-(c-A),x=A-a,c=m*O,g=c-(c-O),d=O-g,b=x*d-(v-a*g-x*g-a*d),S=k*L,c=m*k,a=c-(c-k),x=k-a,c=m*L,g=c-(c-L),d=L-g,R=x*d-(S-a*g-x*g-a*d),y=b-R,o=b-y,j[0]=b-(y+o)+(o-R),E=v+y,o=E-v,w=v-(E-o)+(y-o),y=w-S,o=w-y,j[1]=w-(y+o)+(o-S),_=E+y,o=_-E,j[2]=E-(_-o)+(y-o),j[3]=_;let C=Rt(4,j),Q=At*u;if(C>=Q||-C>=Q||(o=s-A,l=s-(A+o)+(o-r),o=e-L,h=e-(L+o)+(o-r),o=t-k,f=t-(k+o)+(o-i),o=n-O,p=n-(O+o)+(o-i),l===0&&f===0&&h===0&&p===0)||(Q=Lt*u+Pt*Math.abs(C),C+=A*p+O*l-(k*h+L*f),C>=Q||-C>=Q))return C;v=l*O,c=m*l,a=c-(c-l),x=l-a,c=m*O,g=c-(c-O),d=O-g,b=x*d-(v-a*g-x*g-a*d),S=f*L,c=m*f,a=c-(c-f),x=f-a,c=m*L,g=c-(c-L),d=L-g,R=x*d-(S-a*g-x*g-a*d),y=b-R,o=b-y,I[0]=b-(y+o)+(o-R),E=v+y,o=E-v,w=v-(E-o)+(y-o),y=w-S,o=w-y,I[1]=w-(y+o)+(o-S),_=E+y,o=_-E,I[2]=E-(_-o)+(y-o),I[3]=_;const Qt=tt(4,j,4,I,ot);v=A*p,c=m*A,a=c-(c-A),x=A-a,c=m*p,g=c-(c-p),d=p-g,b=x*d-(v-a*g-x*g-a*d),S=k*h,c=m*k,a=c-(c-k),x=k-a,c=m*h,g=c-(c-h),d=h-g,R=x*d-(S-a*g-x*g-a*d),y=b-R,o=b-y,I[0]=b-(y+o)+(o-R),E=v+y,o=E-v,w=v-(E-o)+(y-o),y=w-S,o=w-y,I[1]=w-(y+o)+(o-S),_=E+y,o=_-E,I[2]=E-(_-o)+(y-o),I[3]=_;const Yt=tt(Qt,ot,4,I,lt);v=l*p,c=m*l,a=c-(c-l),x=l-a,c=m*p,g=c-(c-p),d=p-g,b=x*d-(v-a*g-x*g-a*d),S=f*h,c=m*f,a=c-(c-f),x=f-a,c=m*h,g=c-(c-h),d=h-g,R=x*d-(S-a*g-x*g-a*d),y=b-R,o=b-y,I[0]=b-(y+o)+(o-R),E=v+y,o=E-v,w=v-(E-o)+(y-o),y=w-S,o=w-y,I[1]=w-(y+o)+(o-S),_=E+y,o=_-E,I[2]=E-(_-o)+(y-o),I[3]=_;const qt=tt(Yt,lt,4,I,ut);return ut[qt-1]}function Ot(s,t,e,n,r,i){const u=(t-i)*(e-r),l=(s-r)*(n-i),f=u-l,h=Math.abs(u+l);return Math.abs(f)>=Mt*h?f:-kt(s,t,e,n,r,i,h)}const Y=(s,t)=>s.x*t.y-s.y*t.x,ht=(s,t)=>s.x*t.x+s.y*t.y,ft=(s,t,e)=>{const n=Ot(s.x,s.y,t.x,t.y,e.x,e.y);return n>0?-1:n<0?1:0},q=s=>Math.sqrt(ht(s,s)),Nt=(s,t,e)=>{const n={x:t.x-s.x,y:t.y-s.y},r={x:e.x-s.x,y:e.y-s.y};return Y(r,n)/q(r)/q(n)},Bt=(s,t,e)=>{const n={x:t.x-s.x,y:t.y-s.y},r={x:e.x-s.x,y:e.y-s.y};return ht(r,n)/q(r)/q(n)},ct=(s,t,e)=>t.y===0?null:{x:s.x+t.x/t.y*(e-s.y),y:e},at=(s,t,e)=>t.x===0?null:{x:e,y:s.y+t.y/t.x*(e-s.x)},Ct=(s,t,e,n)=>{if(t.x===0)return at(e,n,s.x);if(n.x===0)return at(s,t,e.x);if(t.y===0)return ct(e,n,s.y);if(n.y===0)return ct(s,t,e.y);const r=Y(t,n);if(r==0)return null;const i={x:e.x-s.x,y:e.y-s.y},u=Y(i,t)/r,l=Y(i,n)/r,f=s.x+l*t.x,h=e.x+u*n.x,p=s.y+l*t.y,o=e.y+u*n.y,c=(f+h)/2,a=(p+o)/2;return{x:c,y:a}};class P{static compare(t,e){const n=P.comparePoints(t.point,e.point);return n!==0?n:(t.point!==e.point&&t.link(e),t.isLeft!==e.isLeft?t.isLeft?1:-1:T.compare(t.segment,e.segment))}static comparePoints(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}constructor(t,e){t.events===void 0?t.events=[this]:t.events.push(this),this.point=t,this.isLeft=e}link(t){if(t.point===this.point)throw new Error("Tried to link already linked events");const e=t.point.events;for(let n=0,r=e.length;n<r;n++){const i=e[n];this.point.events.push(i),i.point=this.point}this.checkForConsuming()}checkForConsuming(){const t=this.point.events.length;for(let e=0;e<t;e++){const n=this.point.events[e];if(n.segment.consumedBy===void 0)for(let r=e+1;r<t;r++){const i=this.point.events[r];i.consumedBy===void 0&&n.otherSE.point.events===i.otherSE.point.events&&n.segment.consume(i.segment)}}}getAvailableLinkedEvents(){const t=[];for(let e=0,n=this.point.events.length;e<n;e++){const r=this.point.events[e];r!==this&&!r.segment.ringOut&&r.segment.isInResult()&&t.push(r)}return t}getLeftmostComparator(t){const e=new Map,n=r=>{const i=r.otherSE;e.set(r,{sine:Nt(this.point,t.point,i.point),cosine:Bt(this.point,t.point,i.point)})};return(r,i)=>{e.has(r)||n(r),e.has(i)||n(i);const{sine:u,cosine:l}=e.get(r),{sine:f,cosine:h}=e.get(i);return u>=0&&f>=0?l<h?1:l>h?-1:0:u<0&&f<0?l<h?-1:l>h?1:0:f<u?-1:f>u?1:0}}}let zt=0;class T{static compare(t,e){const n=t.leftSE.point.x,r=e.leftSE.point.x,i=t.rightSE.point.x,u=e.rightSE.point.x;if(u<n)return 1;if(i<r)return-1;const l=t.leftSE.point.y,f=e.leftSE.point.y,h=t.rightSE.point.y,p=e.rightSE.point.y;if(n<r){if(f<l&&f<h)return 1;if(f>l&&f>h)return-1;const o=t.comparePoint(e.leftSE.point);if(o<0)return 1;if(o>0)return-1;const c=e.comparePoint(t.rightSE.point);return c!==0?c:-1}if(n>r){if(l<f&&l<p)return-1;if(l>f&&l>p)return 1;const o=e.comparePoint(t.leftSE.point);if(o!==0)return o;const c=t.comparePoint(e.rightSE.point);return c<0?1:c>0?-1:1}if(l<f)return-1;if(l>f)return 1;if(i<u){const o=e.comparePoint(t.rightSE.point);if(o!==0)return o}if(i>u){const o=t.comparePoint(e.rightSE.point);if(o<0)return 1;if(o>0)return-1}if(i!==u){const o=h-l,c=i-n,a=p-f,x=u-r;if(o>c&&a<x)return 1;if(o<c&&a>x)return-1}return i>u?1:i<u||h<p?-1:h>p?1:t.id<e.id?-1:t.id>e.id?1:0}constructor(t,e,n,r){this.id=++zt,this.leftSE=t,t.segment=this,t.otherSE=e,this.rightSE=e,e.segment=this,e.otherSE=t,this.rings=n,this.windings=r}static fromRing(t,e,n){let r,i,u;const l=P.comparePoints(t,e);if(l<0)r=t,i=e,u=1;else if(l>0)r=e,i=t,u=-1;else throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);const f=new P(r,!0),h=new P(i,!1);return new T(f,h,[n],[u])}replaceRightSE(t){this.rightSE=t,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}bbox(){const t=this.leftSE.point.y,e=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:t<e?t:e},ur:{x:this.rightSE.point.x,y:t>e?t:e}}}vector(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}isAnEndpoint(t){return t.x===this.leftSE.point.x&&t.y===this.leftSE.point.y||t.x===this.rightSE.point.x&&t.y===this.rightSE.point.y}comparePoint(t){if(this.isAnEndpoint(t))return 0;const e=this.leftSE.point,n=this.rightSE.point,r=this.vector();if(e.x===n.x)return t.x===e.x?0:t.x<e.x?1:-1;const i=(t.y-e.y)/r.y,u=e.x+i*r.x;if(t.x===u)return 0;const l=(t.x-e.x)/r.x,f=e.y+l*r.y;return t.y===f?0:t.y<f?-1:1}getIntersection(t){const e=this.bbox(),n=t.bbox(),r=K(e,n);if(r===null)return null;const i=this.leftSE.point,u=this.rightSE.point,l=t.leftSE.point,f=t.rightSE.point,h=F(e,l)&&this.comparePoint(l)===0,p=F(n,i)&&t.comparePoint(i)===0,o=F(e,f)&&this.comparePoint(f)===0,c=F(n,u)&&t.comparePoint(u)===0;if(p&&h)return c&&!o?u:!c&&o?f:null;if(p)return o&&i.x===f.x&&i.y===f.y?null:i;if(h)return c&&u.x===l.x&&u.y===l.y?null:l;if(c&&o)return null;if(c)return u;if(o)return f;const a=Ct(i,this.vector(),l,t.vector());return a===null||!F(r,a)?null:G.round(a.x,a.y)}split(t){const e=[],n=t.events!==void 0,r=new P(t,!0),i=new P(t,!1),u=this.rightSE;this.replaceRightSE(i),e.push(i),e.push(r);const l=new T(r,u,this.rings.slice(),this.windings.slice());return P.comparePoints(l.leftSE.point,l.rightSE.point)>0&&l.swapEvents(),P.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),n&&(r.checkForConsuming(),i.checkForConsuming()),e}swapEvents(){const t=this.rightSE;this.rightSE=this.leftSE,this.leftSE=t,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(let e=0,n=this.windings.length;e<n;e++)this.windings[e]*=-1}consume(t){let e=this,n=t;for(;e.consumedBy;)e=e.consumedBy;for(;n.consumedBy;)n=n.consumedBy;const r=T.compare(e,n);if(r!==0){if(r>0){const i=e;e=n,n=i}if(e.prev===n){const i=e;e=n,n=i}for(let i=0,u=n.rings.length;i<u;i++){const l=n.rings[i],f=n.windings[i],h=e.rings.indexOf(l);h===-1?(e.rings.push(l),e.windings.push(f)):e.windings[h]+=f}n.rings=null,n.windings=null,n.consumedBy=e,n.leftSE.consumedBy=e.leftSE,n.rightSE.consumedBy=e.rightSE}}prevInResult(){return this._prevInResult!==void 0?this._prevInResult:(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null,this._prevInResult)}beforeState(){if(this._beforeState!==void 0)return this._beforeState;if(!this.prev)this._beforeState={rings:[],windings:[],multiPolys:[]};else{const t=this.prev.consumedBy||this.prev;this._beforeState=t.afterState()}return this._beforeState}afterState(){if(this._afterState!==void 0)return this._afterState;const t=this.beforeState();this._afterState={rings:t.rings.slice(0),windings:t.windings.slice(0),multiPolys:[]};const e=this._afterState.rings,n=this._afterState.windings,r=this._afterState.multiPolys;for(let l=0,f=this.rings.length;l<f;l++){const h=this.rings[l],p=this.windings[l],o=e.indexOf(h);o===-1?(e.push(h),n.push(p)):n[o]+=p}const i=[],u=[];for(let l=0,f=e.length;l<f;l++){if(n[l]===0)continue;const h=e[l],p=h.poly;if(u.indexOf(p)===-1)if(h.isExterior)i.push(p);else{u.indexOf(p)===-1&&u.push(p);const o=i.indexOf(h.poly);o!==-1&&i.splice(o,1)}}for(let l=0,f=i.length;l<f;l++){const h=i[l].multiPoly;r.indexOf(h)===-1&&r.push(h)}return this._afterState}isInResult(){if(this.consumedBy)return!1;if(this._isInResult!==void 0)return this._isInResult;const t=this.beforeState().multiPolys,e=this.afterState().multiPolys;switch(M.type){case"union":{const n=t.length===0,r=e.length===0;this._isInResult=n!==r;break}case"intersection":{let n,r;t.length<e.length?(n=t.length,r=e.length):(n=e.length,r=t.length),this._isInResult=r===M.numMultiPolys&&n<r;break}case"xor":{const n=Math.abs(t.length-e.length);this._isInResult=n%2===1;break}case"difference":{const n=r=>r.length===1&&r[0].isSubject;this._isInResult=n(t)!==n(e);break}default:throw new Error(`Unrecognized operation type found ${M.type}`)}return this._isInResult}}class pt{constructor(t,e,n){if(!Array.isArray(t)||t.length===0)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=e,this.isExterior=n,this.segments=[],typeof t[0][0]!="number"||typeof t[0][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const r=G.round(t[0][0],t[0][1]);this.bbox={ll:{x:r.x,y:r.y},ur:{x:r.x,y:r.y}};let i=r;for(let u=1,l=t.length;u<l;u++){if(typeof t[u][0]!="number"||typeof t[u][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");let f=G.round(t[u][0],t[u][1]);f.x===i.x&&f.y===i.y||(this.segments.push(T.fromRing(i,f,this)),f.x<this.bbox.ll.x&&(this.bbox.ll.x=f.x),f.y<this.bbox.ll.y&&(this.bbox.ll.y=f.y),f.x>this.bbox.ur.x&&(this.bbox.ur.x=f.x),f.y>this.bbox.ur.y&&(this.bbox.ur.y=f.y),i=f)}(r.x!==i.x||r.y!==i.y)&&this.segments.push(T.fromRing(i,r,this))}getSweepEvents(){const t=[];for(let e=0,n=this.segments.length;e<n;e++){const r=this.segments[e];t.push(r.leftSE),t.push(r.rightSE)}return t}}class $t{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new pt(t[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(let n=1,r=t.length;n<r;n++){const i=new pt(t[n],this,!1);i.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=i.bbox.ll.x),i.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=i.bbox.ll.y),i.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=i.bbox.ur.x),i.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=i.bbox.ur.y),this.interiorRings.push(i)}this.multiPoly=e}getSweepEvents(){const t=this.exteriorRing.getSweepEvents();for(let e=0,n=this.interiorRings.length;e<n;e++){const r=this.interiorRings[e].getSweepEvents();for(let i=0,u=r.length;i<u;i++)t.push(r[i])}return t}}class gt{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{typeof t[0][0][0]=="number"&&(t=[t])}catch(n){}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(let n=0,r=t.length;n<r;n++){const i=new $t(t[n],this);i.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=i.bbox.ll.x),i.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=i.bbox.ll.y),i.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=i.bbox.ur.x),i.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=i.bbox.ur.y),this.polys.push(i)}this.isSubject=e}getSweepEvents(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const r=this.polys[e].getSweepEvents();for(let i=0,u=r.length;i<u;i++)t.push(r[i])}return t}}class X{static factory(t){const e=[];for(let n=0,r=t.length;n<r;n++){const i=t[n];if(!i.isInResult()||i.ringOut)continue;let u=null,l=i.leftSE,f=i.rightSE;const h=[l],p=l.point,o=[];for(;u=l,l=f,h.push(l),l.point!==p;)for(;;){const c=l.getAvailableLinkedEvents();if(c.length===0){const g=h[0].point,d=h[h.length-1].point;throw new Error(`Unable to complete output ring starting at [${g.x}, ${g.y}]. Last matching segment found ends at [${d.x}, ${d.y}].`)}if(c.length===1){f=c[0].otherSE;break}let a=null;for(let g=0,d=o.length;g<d;g++)if(o[g].point===l.point){a=g;break}if(a!==null){const g=o.splice(a)[0],d=h.splice(g.index);d.unshift(d[0].otherSE),e.push(new X(d.reverse()));continue}o.push({index:h.length,point:l.point});const x=l.getLeftmostComparator(u);f=c.sort(x)[0].otherSE;break}e.push(new X(h))}return e}constructor(t){this.events=t;for(let e=0,n=t.length;e<n;e++)t[e].segment.ringOut=this;this.poly=null}getGeom(){let t=this.events[0].point;const e=[t];for(let h=1,p=this.events.length-1;h<p;h++){const o=this.events[h].point,c=this.events[h+1].point;ft(o,t,c)!==0&&(e.push(o),t=o)}if(e.length===1)return null;const n=e[0],r=e[1];ft(n,t,r)===0&&e.shift(),e.push(e[0]);const i=this.isExteriorRing()?1:-1,u=this.isExteriorRing()?0:e.length-1,l=this.isExteriorRing()?e.length:-1,f=[];for(let h=u;h!=l;h+=i)f.push([e[h].x,e[h].y]);return f}isExteriorRing(){if(this._isExteriorRing===void 0){const t=this.enclosingRing();this._isExteriorRing=t?!t.isExteriorRing():!0}return this._isExteriorRing}enclosingRing(){return this._enclosingRing===void 0&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}_calcEnclosingRing(){let t=this.events[0];for(let r=1,i=this.events.length;r<i;r++){const u=this.events[r];P.compare(t,u)>0&&(t=u)}let e=t.segment.prevInResult(),n=e?e.prevInResult():null;for(;;){if(!e)return null;if(!n)return e.ringOut;if(n.ringOut!==e.ringOut)return n.ringOut.enclosingRing()!==e.ringOut?e.ringOut:e.ringOut.enclosingRing();e=n.prevInResult(),n=e?e.prevInResult():null}}}class xt{constructor(t){this.exteriorRing=t,t.poly=this,this.interiorRings=[]}addInterior(t){this.interiorRings.push(t),t.poly=this}getGeom(){const t=[this.exteriorRing.getGeom()];if(t[0]===null)return null;for(let e=0,n=this.interiorRings.length;e<n;e++){const r=this.interiorRings[e].getGeom();r!==null&&t.push(r)}return t}}class Tt{constructor(t){this.rings=t,this.polys=this._composePolys(t)}getGeom(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const r=this.polys[e].getGeom();r!==null&&t.push(r)}return t}_composePolys(t){const e=[];for(let n=0,r=t.length;n<r;n++){const i=t[n];if(!i.poly)if(i.isExteriorRing())e.push(new xt(i));else{const u=i.enclosingRing();u.poly||e.push(new xt(u)),u.poly.addInterior(i)}}return e}}class jt{constructor(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:T.compare;this.queue=t,this.tree=new H(e),this.segments=[]}process(t){const e=t.segment,n=[];if(t.consumedBy)return t.isLeft?this.queue.remove(t.otherSE):this.tree.remove(e),n;const r=t.isLeft?this.tree.add(e):this.tree.find(e);if(!r)throw new Error(`Unable to find segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] in SweepLine tree.`);let i=r,u=r,l,f;for(;l===void 0;)i=this.tree.prev(i),i===null?l=null:i.key.consumedBy===void 0&&(l=i.key);for(;f===void 0;)u=this.tree.next(u),u===null?f=null:u.key.consumedBy===void 0&&(f=u.key);if(t.isLeft){let h=null;if(l){const o=l.getIntersection(e);if(o!==null&&(e.isAnEndpoint(o)||(h=o),!l.isAnEndpoint(o))){const c=this._splitSafely(l,o);for(let a=0,x=c.length;a<x;a++)n.push(c[a])}}let p=null;if(f){const o=f.getIntersection(e);if(o!==null&&(e.isAnEndpoint(o)||(p=o),!f.isAnEndpoint(o))){const c=this._splitSafely(f,o);for(let a=0,x=c.length;a<x;a++)n.push(c[a])}}if(h!==null||p!==null){let o=null;h===null?o=p:p===null?o=h:o=P.comparePoints(h,p)<=0?h:p,this.queue.remove(e.rightSE),n.push(e.rightSE);const c=e.split(o);for(let a=0,x=c.length;a<x;a++)n.push(c[a])}n.length>0?(this.tree.remove(e),n.push(t)):(this.segments.push(e),e.prev=l)}else{if(l&&f){const h=l.getIntersection(f);if(h!==null){if(!l.isAnEndpoint(h)){const p=this._splitSafely(l,h);for(let o=0,c=p.length;o<c;o++)n.push(p[o])}if(!f.isAnEndpoint(h)){const p=this._splitSafely(f,h);for(let o=0,c=p.length;o<c;o++)n.push(p[o])}}}this.tree.remove(e)}return n}_splitSafely(t,e){this.tree.remove(t);const n=t.rightSE;this.queue.remove(n);const r=t.split(e);return r.push(n),t.consumedBy===void 0&&this.tree.add(t),r}}const yt=typeof et!="undefined"&&{NODE_ENV:"production",UMI_APP_API_PREFIX:"https://api.3steps.cn/biominer-indexd",PUBLIC_PATH:"/"}.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,Ft=typeof et!="undefined"&&{NODE_ENV:"production",UMI_APP_API_PREFIX:"https://api.3steps.cn/biominer-indexd",PUBLIC_PATH:"/"}.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6;class Gt{run(t,e,n){M.type=t,G.reset();const r=[new gt(e,!0)];for(let o=0,c=n.length;o<c;o++)r.push(new gt(n[o],!1));if(M.numMultiPolys=r.length,M.type==="difference"){const o=r[0];let c=1;for(;c<r.length;)K(r[c].bbox,o.bbox)!==null?c++:r.splice(c,1)}if(M.type==="intersection")for(let o=0,c=r.length;o<c;o++){const a=r[o];for(let x=o+1,g=r.length;x<g;x++)if(K(a.bbox,r[x].bbox)===null)return[]}const i=new H(P.compare);for(let o=0,c=r.length;o<c;o++){const a=r[o].getSweepEvents();for(let x=0,g=a.length;x<g;x++)if(i.insert(a[x]),i.size>yt)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).")}const u=new jt(i);let l=i.size,f=i.pop();for(;f;){const o=f.key;if(i.size===l){const a=o.segment;throw new Error(`Unable to pop() ${o.isLeft?"left":"right"} SweepEvent [${o.point.x}, ${o.point.y}] from segment #${a.id} [${a.leftSE.point.x}, ${a.leftSE.point.y}] -> [${a.rightSE.point.x}, ${a.rightSE.point.y}] from queue.`)}if(i.size>yt)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");if(u.segments.length>Ft)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");const c=u.process(o);for(let a=0,x=c.length;a<x;a++){const g=c[a];g.consumedBy===void 0&&i.insert(g)}l=i.size,f=i.pop()}G.reset();const h=X.factory(u.segments);return new Tt(h).getGeom()}}const M=new Gt;var Ut={union:function(s){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return M.run("union",s,e)},intersection:function(s){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return M.run("intersection",s,e)},xor:function(s){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return M.run("xor",s,e)},difference:function(s){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return M.run("difference",s,e)}};return Ut})}}]);
